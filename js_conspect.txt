
В js есть несколько типов значений: фиксированные (литералы), значения констант, значения переменных:
25 (литерал целого числа), 23.8 (литерал дробного числа), 'JavaScript' (литерал строки), [15,7,89] (литерал массива),
{name: 'Yaroslav' surname: 'Domagic'} (литерал объекта), (ab|bc) (литерал регулярного выражения) 
-----------------------------------------------

константы и переменные используются для хранения значений данных:
const MAX_VALUE = 17; - константа
var section = 'JS'; - переменная
let arr = ['HTML','CSS','JS']; - переменная
.
ПЕРЕМЕННАЯ:
-- ключевое слово let для объявления переменной. Имя переменной может сожержать только буквы, цифры, символы($_), 
первый символ не должен быть цифрой. Если переменная состоит из нескольких слов, то каждое следующее слово с большой 
буквы (leftSidebarSize).  
-- может объявляться без значения (let sidebar) и со значением (let sidebar = 'left';). Если объявляли переменную без 
значения, то потом значение можно писать без let (sidebar = 'left'). Переменные стоит объявлять в столбик используя let 
либо один раз либо каждый: 
let myName = 'Ярик', 
    myAge = '33',
    myMessage = 'учись сильнее';
-- Значение переменной можно менять по ходу и будет применяться последнее значение. Переменные могут передавать значение.
myAge = myNewAge;
.
КОНСТАНТА (та же переменная, но ее значение нельзя изменить)
-- ключевое слово const. Все тоже самое что и let кроме ряда нюансов: 
имена констант с заранее известными значениями пишутся верхним регистром через нижнее подчеркивание
const BLOCK_SIZE = 25; 
const COLOR_RED = '#F00';
.
VAR (та же переменная но с рядом отличий)
-- ключевое слово var. Использовать переменную можно до ее ообъявления (в отличии от let) 
age = 35;
var age;
-- Область видимости. В условиях, циклах (if...) var будет видна за пределами блока (в отличии от let):
if(true) {
  var sizeVar = 50;
}
-----------------------------------------------------------------------------

ТИПЫ ДАННЫХ 
-- тип данных переменной меняется динамически в момент присвоения либо смены ее значения, а не в момент объявления.
оператор typeof (console.log(typeof userName)) покажет тип данных переменной (строка, число...)
.
Undefined - неопределенный (если объявлена переменная, но не присвоено значение)
Null - также как и undefined, содержит только одно значение null (переменная определена, но ее значение равно ничего или 
неизвестно)
Boolean - булевый или логический тип. Может принимать только два значения true и false (используется для хранения
значений да/нет 
Number - числовой тип данных представляет значение как в виде целых чисел, так и в виде чисел с плавающей точкой. NaN - 
означает математическую вычислительную ошибку (результат неправильной или неопределённой математической операции)
BigInt - был добавлен чтобы дать возможность работать с целыми числами произвольной длины 
const bigInt = 1234567890123456789012345678901234567890n ("n" в конце означает, что это BigInt)
String (cтрока) - должна быть заключена в кавычки ("", '', ``(позволяют встраивать выражения в строку, заключая их в ${…})
let name = "Иван";
Вставим переменную
alert( `Привет, ${name}!` ); - Привет, Иван!
Object - в объектах хранят набор данных или более сложные структуры.
let userInfo = {
  name: "Yarik",    (содержит набор необязательных свойств - пара ключ+значение. Разделяются запятой) 
  age: "33"	    
}
Symbol - для уникальных идентификаторов. ( пример let id = Symbol("id"); )
.
ПРЕОБРАЗОВАНИЕ типов данных: 
-- Строковое – когда нужно что-то вывести. Может быть вызвано с помощью String(value). Для примитивных значений работает 
очевидным образом.

let value = true;
alert(typeof value); (выведет boolean)
value = String(value); (теперь value это строка "true")
alert(typeof value);  (выведет string)

-- Численное – происходит в математических операциях. Может быть вызвано с помощью Number(value)

let str = "123";
alert(typeof str); (выведет string)
let num = Number(str); (становится числом 123)
alert(typeof num);  (выведет number) 

-- Логическое – происходит в логических операциях. Может быть вызвано с помощью Boolean(value).

alert( Boolean(1) ); (выведет true)
alert( Boolean(0) ); (выведет false)
alert( Boolean("Привет!") ); (true)
alert( Boolean("") );        (false)

------------------------------------------------------------------------------

Взаимодействие встроенных функций alert, promt, confirm  
-- alert - показывает сообщение и ждет, пока пользователь нажмёт кнопку ОК (alert("Hello");)
-- prompt - принимает два аргумента. Отобразит модальное окно с текстом, полем для ввода текста и кнопками OK/Отмена.
Вызов prompt возвращает текст, указанный в поле для ввода, или null, если ввод отменён пользователем.
let age = prompt('Сколько тебе лет?', 100);
alert(`Тебе ${age} лет!`);
-- confirm отображает модальное окно с текстом вопроса и двумя кнопками: OK (true) и Отмена (false)
let isBoss = confirm("Ты здесь главный?");
alert( isBoss ); (віведет true, если нажата OK)
------------------------------------------------------------------------------

Операторы. Обозначают операцию, которую нужно произвести: 
* / + - =        -  (пример console.log('Learn'+'JS');
.

Выражение (expression) - комбинация значений, переменных и операторов, которые либо присваивают какое-то значение,
либо возвращают какое-то значение без его присваения: 
let num = 4; - выражение присвоения
console.log(num);
'Learn' + 'JS' - выражение без присвоения
.

------------------------------------------------------------------------------

ЦИКЛЫ while и for
Для многократного повторения одного участка кода предусмотрены циклы (пример: вывести товары из списка один за другим)
-- While (condition) {
   код - тело цикла
}
.
Код из тела цикла выполняется, пока условие condition истинно.

let i = 0;
while (i < 3) { выводит 0, затем 1, затем 2     (цикл выводит i, пока i < 3)
  alert( i );
  i++;
}

Одно выполнение тела цикла называется итерация. 

Любое выражение или переменная может быть условием цикла, а не только сравнение: 
условие while вычисляется и преобразуется в логическое значение.

Например, while (i) – более краткий вариант while (i != 0):

let i = 3;
while (i) { // когда i будет равно 0, условие станет ложным, и цикл остановится
  alert( i );
  i--;
}
.
-- Цикл «do…while». Проверку условия можно разместить под телом цикла:
  
do {                         Цикл сначала выполнит тело, а затем проверит условие condition, 
  // тело цикла              и пока его значение равно true, он будет выполняться снова и снова.
} while (condition);
.
let i = 0;                   Такая форма синтаксиса оправдана, если вы хотите, чтобы тело цикла 
  alert( i );                выполнилось хотя бы один раз, даже если условие окажется ложным. 
  i++;                        
} while (i < 3);
.
-- Цикл «for».

for (начало; условие; шаг) {
  // ... тело цикла ...
}
.

for (let i = 0; i < 3; i++) { // выведет 0, затем 1, затем 2
  alert(i);
}

начало	i = 0	Выполняется один раз при входе в цикл
условие	i < 3	Проверяется перед каждой итерацией цикла. Если оно вычислится в false, цикл остановится.
шаг	i++	Выполняется после тела цикла на каждой итерации перед проверкой условия.
тело	alert(i)	Выполняется снова и снова, пока условие вычисляется в true.

В примере переменная счётчика i была объявлена прямо в цикле. Это «встроенное» объявление переменной. 
Такие переменные существуют только внутри цикла.
Вместо объявления новой переменной мы можем использовать уже существующую
Любая часть for может быть пропущена. (на месте пропуска ставится точка с запятой).
.
-- можем выйти из цикла в любой момент с помощью специальной директивы break.
-- Директива continue – «облегчённая версия» break. При её выполнении цикл не прерывается, а переходит к следующей 
итерации (если условие все ещё равно true). Её используют, если понятно, что на текущем повторе цикла делать больше нечего.

 

-------------------------------------------------------------------------------

ФУНКЦИИ. Блоки инструкций (фигурные скобочки - {}). Не повторять один и тот же код во многих местах - функции.
function name() {       - (ключевое слово function, имя функции, список параметров в круглых скобках через запятую)
 console.log('Learn');  - (тело функции)
 console.log('JS');
}
name();  - (вызов функции). 
.
-- Переменные, объявленные внутри функции, видны только внутри этой функции.
.
-- Функция обладает полным доступом к внешним переменным и может изменять их значение.
let userName = 'Вася';

function showMessage() {
  userName = "Петя"; // (1) изменяем значение внешней переменной

  let message = 'Привет, ' + userName;
  alert(message);
}

alert( userName ); // Вася перед вызовом функции

showMessage();

alert( userName ); // Петя, значение внешней переменной было изменено функцией
.
-- Внешняя переменная используется, только если внутри функции нет такой локальной.Если одноимённая переменная объявляется 
внутри функции, тогда она перекрывает внешнюю.
.
-- Переменные, объявленные снаружи всех функций, такие как внешняя переменная – называются глобальными.Глобальные 
переменные видимы для любой функции (если только их не перекрывают одноимённые локальные переменные). 
Желательно сводить использование глобальных переменных к минимуму.
.
-- Параметры - передать внутрь функции любую информацию (также называемые аргументами функции).
function showMessage(from, text) { // аргументы: from, text
  alert(from + ': ' + text);
}

showMessage('Аня', 'Привет!'); // Аня: Привет!
showMessage('Аня', "Как дела?"); // Аня: Как дела?
Если параметр не указан, то его значением становится undefined.
.
-- Возврат значения - функция может вернуть результат, который будет передан в вызвавший её код.

function sum(a, b) {         (Директива return может находиться в любом месте тела функции. Как только выполнение 
  return a + b;               доходит до этого места, функция останавливается, и значение возвращается в вызвавший её 
                              код (присваивается переменной result выше).
}

let result = sum(1, 2);       Вызовов return может быть несколько
alert( result ); // 3

Возможно использовать return без значения (немедленный выход из функции) 
.
Функции, начинающиеся с…
showMessage(..)     // показывает сообщение
getAge(..)          // возвращает возраст (в каком либо значении)
calcSum(..)         // вычисляет сумму и возвращает результат
createForm(..)      // создаёт форму (и обычно возвращает её)
checkPermission(..) // проверяет доступ, возвращая true/false
.
Функции должны быть короткими и делать только что-то одно. Если это что-то большое, имеет смысл разбить функцию 
на несколько меньших.
.

ФУНКЦИОНАЛЬНОЕ ВЫРАЖЕНИЕ (Function Expression)

let sayHi = function() {
  alert( "Привет" );
};

-- Можем скопировать функцию в другую переменную

function sayHi() {   // (1) создаём                
  alert( "Привет" );
}

let func = sayHi;    // (2) копируем

func(); // Привет    // (3) вызываем копию (работает)!
sayHi(); // Привет   //     прежняя тоже работает (почему бы нет)
.

ФУНКЦИИ КОЛБЭКИ

-- Передаём функцию и ожидаем, что она вызовется обратно (от англ. «call back» – обратный вызов) когда-нибудь позже, 
если это будет необходимо.
.

СТРЕЛОЧНЫЕ ФУНКЦИИ (arrow functions)

-- let func = (arg1, arg2, ...argN) => expression.    Такой код создаёт функцию func с аргументами arg1..argN и
                                                      вычисляет expression с правой стороны с их использованием, 
Более длинный вариант:                                возвращая результат.

let func = function(arg1, arg2, ...argN) {
  return expression;
};
.
.

let sum = (a, b) => a + b;

/* Более короткая форма для:

let sum = function(a, b) {         То есть, (a, b) => a + b задаёт функцию 
  return a + b;                    с двумя аргументами a и b, которая при запуске вычисляет 
};                                 выражение справа a + b и возвращает его результат.
*/

alert( sum(1, 2) ); // 3

Если нет аргументов, указываются пустые круглые скобки:

let sayHi = () => alert("Hello!");

sayHi();
.
-- Многострочные стрелочные функции

let sum = (a, b) => {  // фигурная скобка, открывающая тело многострочной функции
  let result = a + b;
  return result; // при фигурных скобках для возврата значения нужно явно вызвать return
};

alert( sum(1, 2) ); // 3



