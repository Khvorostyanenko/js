test ГДЕ ИСКАТЬ ОТВЕТЫ (документация по ДжаваСкрипт): в Гугле MDN (Moz Dev Networks) и потом нужный запрос.  


В js есть несколько типов значений: фиксированные (литералы), значения констант, значения переменных:
25 (литерал целого числа), 23.8 (литерал дробного числа), 'JavaScript' (литерал строки), [15,7,89] (литерал массива),
{name: 'Yaroslav' surname: 'Domagic'} (литерал объекта), (ab|bc) (литерал регулярного выражения) 
-----------------------------------------------

константы и переменные используются для хранения значений данных:
const MAX_VALUE = 17; - константа
var section = 'JS'; - переменная
let arr = ['HTML','CSS','JS']; - переменная
.
ПЕРЕМЕННАЯ:
-- ключевое слово let для объявления переменной. Имя переменной может сожержать только буквы, цифры, символы($_), 
первый символ не должен быть цифрой. Если переменная состоит из нескольких слов, то каждое следующее слово с большой 
буквы (leftSidebarSize).  
-- может объявляться без значения (let sidebar) и со значением (let sidebar = 'left';). Если объявляли переменную без 
значения, то потом значение можно писать без let (sidebar = 'left'). Переменные стоит объявлять в столбик используя let 
либо один раз либо каждый: 
let myName = 'Ярик', 
    myAge = '33',
    myMessage = 'учись сильнее';
-- Значение переменной можно менять по ходу и будет применяться последнее значение. Переменные могут передавать значение.
myAge = myNewAge;
.
КОНСТАНТА (та же переменная, но ее значение нельзя изменить)
-- ключевое слово const. Все тоже самое что и let кроме ряда нюансов: 
имена констант с заранее известными значениями пишутся верхним регистром через нижнее подчеркивание
const BLOCK_SIZE = 25; 
const COLOR_RED = '#F00';
.
VAR (та же переменная но с рядом отличий)
-- ключевое слово var. Использовать переменную можно до ее ообъявления (в отличии от let) 
age = 35;
var age;
-- Область видимости. В условиях, циклах (if...) var будет видна за пределами блока (в отличии от let):
if(true) {
  var sizeVar = 50;
}
-----------------------------------------------------------------------------

ТИПЫ ДАННЫХ 
-- тип данных переменной меняется динамически в момент присвоения либо смены ее значения, а не в момент объявления.
оператор typeof (console.log(typeof userName)) покажет тип данных переменной (строка, число...)
.
Undefined - неопределенный (если объявлена переменная, но не присвоено значение)
Null - также как и undefined, содержит только одно значение null (переменная определена, но ее значение равно ничего или 
неизвестно)
Boolean - булевый или логический тип. Может принимать только два значения true и false (используется для хранения
значений да/нет 
Number - числовой тип данных представляет значение как в виде целых чисел, так и в виде чисел с плавающей точкой. 
(цельное 42 и плавающее 42.38 / integer float) NaN - означает математическую вычислительную ошибку (результат 
неправильной или неопределённой математической операции)
BigInt - был добавлен чтобы дать возможность работать с целыми числами произвольной длины 
const bigInt = 1234567890123456789012345678901234567890n ("n" в конце означает, что это BigInt)
String (cтрока) - должна быть заключена в кавычки ("", '', ``(позволяют встраивать выражения в строку, заключая их в ${…})
let name = "Иван";
Вставим переменную
alert( `Привет, ${name}!` ); - Привет, Иван!
Object - в объектах хранят набор данных или более сложные структуры.
let userInfo = {
  name: "Yarik",    (содержит набор необязательных свойств - пара ключ+значение. Разделяются запятой) 
  age: "33"	    
}
Symbol - для уникальных идентификаторов. ( пример let id = Symbol("id"); )
.
ПРЕОБРАЗОВАНИЕ типов данных: 
-- Строковое – когда нужно что-то вывести. Может быть вызвано с помощью String(value). Для примитивных значений работает 
очевидным образом.

let value = true;
alert(typeof value); (выведет boolean)
value = String(value); (теперь value это строка "true")
alert(typeof value);  (выведет string)

-- Численное – происходит в математических операциях. Может быть вызвано с помощью Number(value)

let str = "123";
alert(typeof str); (выведет string)
let num = Number(str); (становится числом 123)
alert(typeof num);  (выведет number) 

-- Логическое – происходит в логических операциях. Может быть вызвано с помощью Boolean(value).

alert( Boolean(1) ); (выведет true)
alert( Boolean(0) ); (выведет false)
alert( Boolean("Привет!") ); (true)
alert( Boolean("") );        (false)

------------------------------------------------------------------------------

Взаимодействие встроенных функций alert, promt, confirm  
-- alert - показывает сообщение и ждет, пока пользователь нажмёт кнопку ОК (alert("Hello");)
-- prompt - принимает два аргумента. Отобразит модальное окно с текстом, полем для ввода текста и кнопками OK/Отмена.
Вызов prompt возвращает текст, указанный в поле для ввода, или null, если ввод отменён пользователем.
let age = prompt('Сколько тебе лет?', 100);
alert(`Тебе ${age} лет!`);
-- confirm отображает модальное окно с текстом вопроса и двумя кнопками: OK (true) и Отмена (false)
let isBoss = confirm("Ты здесь главный?");
alert( isBoss ); (віведет true, если нажата OK)
------------------------------------------------------------------------------

Операторы. Обозначают операцию, которую нужно произвести: 
* / + - =        -  (пример console.log('Learn'+'JS');
.
let currentYear = 2020   
console.log(currentYear++) выведет 2020
console.log(currentYear) следом уже выведет 2021    (оператор ++ увеличивает (инкреминтирует) значение на 1 единицу).
.
оператор -- делает аналогично но в обратную сторону.  

Выражение (expression) - комбинация значений, переменных и операторов, которые либо присваивают какое-то значение,
либо возвращают какое-то значение без его присваения: 
let num = 4; - выражение присвоения
console.log(num);
'Learn' + 'JS' - выражение без присвоения
.
-- приоритет операторов (в моз дев нетвор ищем приоритет операторов и там есть табличка от 1 до 20 где 20 это наивысший
приоритет, а 1 это наинизший)

const fullAge = 33
const birthYear = 1987
const currentYear = 2020
const isFullAge = currentYear - birthYear >= fullAge // 33 => true (выполнится сначала вычитание (в табличке выше) а потом
                                                                    сравннение) 
Если поставить в фигурные скобочки то вычитание тоже будет первым, так как у скобочек приоритет выше
const isFullAge = (currentYear - birthYear) >= fullAge

-- условные операторы 
.
const courceStatus = 'pending' // ready, fail, pending            else оптимизирует производительность при запросах и
if (courceStatus === 'ready') {                                   проверки условий 
  console.log('КУрс уже готов и его можно проходить') 	
}else if (courceStatus === 'pending') {                           === равно проверяет по всем типам данных. Это важно
  console.log('курс в процессе разроботки') 	                  помнить новичкам. (вместо двойного равно).ТАк что 
}                                                                 нужно использовать ТРОЙНОЕ

------------------------------------------------------------------------------

ЦИКЛЫ while и for + новый of
Для многократного повторения одного участка кода предусмотрены циклы (пример: вывести товары из списка один за другим)
-- While (condition) {
   код - тело цикла
}
.
Код из тела цикла выполняется, пока условие condition истинно.

let i = 0;
while (i < 3) { выводит 0, затем 1, затем 2     (цикл выводит i, пока i < 3)
  alert( i );
  i++;
}

Одно выполнение тела цикла называется итерация. 

Любое выражение или переменная может быть условием цикла, а не только сравнение: 
условие while вычисляется и преобразуется в логическое значение.

Например, while (i) – более краткий вариант while (i != 0):

let i = 3;
while (i) { // когда i будет равно 0, условие станет ложным, и цикл остановится
  alert( i );
  i--;
} 
.
-- Цикл «do…while». Проверку условия можно разместить под телом цикла:
  
do {                         Цикл сначала выполнит тело, а затем проверит условие condition, 
  // тело цикла              и пока его значение равно true, он будет выполняться снова и снова.
} while (condition);
.
let i = 0;                   Такая форма синтаксиса оправдана, если вы хотите, чтобы тело цикла 
  alert( i );                выполнилось хотя бы один раз, даже если условие окажется ложным. 
  i++;                        
} while (i < 3);
.
-- Цикл «for».

for (начало; условие; шаг) {
  // ... тело цикла ...
}
.

for (let i = 0; i < 3; i++) { // выведет 0, затем 1, затем 2
  alert(i);
}

начало	i = 0	Выполняется один раз при входе в цикл
условие	i < 3	Проверяется перед каждой итерацией цикла. Если оно вычислится в false, цикл остановится.
шаг	i++	Выполняется после тела цикла на каждой итерации перед проверкой условия.
тело	alert(i)	Выполняется снова и снова, пока условие вычисляется в true.

В примере переменная счётчика i была объявлена прямо в цикле. Это «встроенное» объявление переменной. 
Такие переменные существуют только внутри цикла.
Вместо объявления новой переменной мы можем использовать уже существующую
Любая часть for может быть пропущена. (на месте пропуска ставится точка с запятой).
.
-- можем выйти из цикла в любой момент с помощью специальной директивы break.
-- Директива continue – «облегчённая версия» break. При её выполнении цикл не прерывается, а переходит к следующей 
итерации (если условие все ещё равно true). Её используют, если понятно, что на текущем повторе цикла делать больше нечего.
.
-- цикл of 

for (let car of cars) {
console.log(car)                создаем переменную, которая сразу же является элементом массива
}
 

-------------------------------------------------------------------------------
.
УСЛОВНОЕ ВЕТВЛЕНИЕ: if, '?'

-- Инструкция if(...) вычисляет условие в скобках и, если результат true, то выполняет блок кода.

let year = prompt('В каком году была опубликована спецификация ECMAScript-2015?', '');
if (year == 2015) alert( 'Вы правы!' );

Если мы хотим выполнить более одной инструкции, то нужно заключить блок кода в фигурные скобки:
if (year == 2015) {
  alert( "Правильно!" );
  alert( "Вы такой умный!" );
}

-- Инструкция if может содержать необязательный блок «else» («иначе»). Он выполняется, когда условие ложно.
let year = prompt('В каком году была опубликована спецификация ECMAScript-2015?', '');

if (year == 2015) {
  alert( 'Да вы знаток!' );
} else {
  alert( 'А вот и неправильно!' ); // любое значение, кроме 2015
}
.
-- «условный» оператор «вопросительный знак» позволяет нам сделать это более коротким и простым способом.
Сначала вычисляется условие: если оно истинно, тогда возвращается значение1, в противном случае – значение2.
let accessAllowed = (age > 18) ? true : false;

-------------------------------------------------------------------------------

.
КОНСТРУКЦИЯ «switch»

-- Конструкция switch заменяет собой сразу несколько if
Конструкция switch имеет один или более блок case и необязательный блок default

let a = 2 + 2;

switch (a) {                        Здесь оператор switch последовательно сравнит a со всеми вариантами из case.
                                    Сначала 3, затем – так как нет совпадения – 4. Совпадение найдено, будет выполнен 
  case 3:                           этот вариант, со строки alert( 'В точку!' ) и далее, до ближайшего break, 
    alert( 'Маловато' );            который прервёт выполнение.
    break;
  case 4:
    alert( 'В точку!' );
    break;
  case 5:
    alert( 'Перебор' );
    break;
  default:
    alert( "Нет таких значений" );
}

И switch и case допускают любое выражение в качестве аргумента.

let a = "1";                    Выражение +a вычисляется в 1, что совпадает с выражением b + 1 в case, и следовательно, 
let b = 0;                      код в этом блоке будет выполнен.

switch (+a) {
  case b + 1:
    alert("Выполнится, т.к. значением +a будет 1, что в точности равно b+1");
    break;

  default:
    alert("Это не выполнится");
}

-------------------------------------------------------------------------------

ФУНКЦИИ. Блоки инструкций (фигурные скобочки - {}). Не повторять один и тот же код во многих местах - функции.
Функции на самом деле являются объектами. 

(FUNCTION DECLARATION)
к FUNCTION DECLARATION можно обращатьтся когда мы захотим, в отличии от Function Expression. 
(пример https://youtu.be/Bluxbh9CaQ0?t=9894)

function name() {       - (ключевое слово function, имя функции, список параметров в круглых скобках через запятую)
 console.log('Learn');  - (тело функции)
 console.log('JS');
}
name();  - (вызов функции). 
.
-- Переменные, объявленные внутри функции, видны только внутри этой функции.
.
-- Функция обладает полным доступом к внешним переменным и может изменять их значение.
let userName = 'Вася';

function showMessage() {
  userName = "Петя"; // (1) изменяем значение внешней переменной

  let message = 'Привет, ' + userName;
  alert(message);
}

alert( userName ); // Вася перед вызовом функции

showMessage();

alert( userName ); // Петя, значение внешней переменной было изменено функцией
.
-- Внешняя переменная используется, только если внутри функции нет такой локальной.Если одноимённая переменная объявляется 
внутри функции, тогда она перекрывает внешнюю.
.
-- Переменные, объявленные снаружи всех функций, такие как внешняя переменная – называются глобальными.Глобальные 
переменные видимы для любой функции (если только их не перекрывают одноимённые локальные переменные). 
Желательно сводить использование глобальных переменных к минимуму.
.
-- Параметры - передать внутрь функции любую информацию (также называемые аргументами функции).
function showMessage(from, text) { // аргументы: from, text
  alert(from + ': ' + text);
}

showMessage('Аня', 'Привет!'); // Аня: Привет!
showMessage('Аня', "Как дела?"); // Аня: Как дела?
Если параметр не указан, то его значением становится undefined.
.
-- Возврат значения - функция может вернуть результат, который будет передан в вызвавший её код.

function sum(a, b) {         (Директива return может находиться в любом месте тела функции. Как только выполнение 
  return a + b;               доходит до этого места, функция останавливается, и значение возвращается в вызвавший её 
                              код (присваивается переменной result выше).
}

let result = sum(1, 2);       Вызовов return может быть несколько
alert( result ); // 3

Возможно использовать return без значения (немедленный выход из функции) 
.
Функции, начинающиеся с…
showMessage(..)     // показывает сообщение
getAge(..)          // возвращает возраст (в каком либо значении)
calcSum(..)         // вычисляет сумму и возвращает результат
createForm(..)      // создаёт форму (и обычно возвращает её)
checkPermission(..) // проверяет доступ, возвращая true/false
.
Функции должны быть короткими и делать только что-то одно. Если это что-то большое, имеет смысл разбить функцию 
на несколько меньших.
.

ФУНКЦИОНАЛЬНОЕ ВЫРАЖЕНИЕ (Function Expression)

В отличии от FUNCTION DECLARATION тут мы заносим функцию в переменную. 
к FUNCTION DECLARATION можно обращатьтся когда мы захотим, в отличии от Function Expression. 
(пример https://youtu.be/Bluxbh9CaQ0?t=9894)

let sayHi = function() {
  alert( "Привет" );
};

-- Можем скопировать функцию в другую переменную

function sayHi() {   // (1) создаём                
  alert( "Привет" );
}

let func = sayHi;    // (2) копируем

func(); // Привет    // (3) вызываем копию (работает)!
sayHi(); // Привет   //     прежняя тоже работает (почему бы нет)
.

ФУНКЦИИ КОЛБЭКИ

-- Передаём функцию и ожидаем, что она вызовется обратно (от англ. «call back» – обратный вызов) когда-нибудь позже, 
если это будет необходимо.
.

СТРЕЛОЧНЫЕ ФУНКЦИИ (arrow functions)

Существенно упрощает работу с функциями. 

-- let func = (arg1, arg2, ...argN) => expression.    Такой код создаёт функцию func с аргументами arg1..argN и
                                                      вычисляет expression с правой стороны с их использованием, 
Более длинный вариант:                                возвращая результат.

let func = function(arg1, arg2, ...argN) {
  return expression;
};
.
.

let sum = (a, b) => a + b;

/* Более короткая форма для:

let sum = function(a, b) {         То есть, (a, b) => a + b задаёт функцию 
  return a + b;                    с двумя аргументами a и b, которая при запуске вычисляет 
};                                 выражение справа a + b и возвращает его результат.
*/

alert( sum(1, 2) ); // 3

Если нет аргументов, указываются пустые круглые скобки:

let sayHi = () => alert("Hello!");

sayHi();
.
-- Многострочные стрелочные функции

let sum = (a, b) => {  // фигурная скобка, открывающая тело многострочной функции
  let result = a + b;
  return result; // при фигурных скобках для возврата значения нужно явно вызвать return
};

alert( sum(1, 2) ); // 3

-- Добавились параметры по умолчканию (пример https://youtu.be/Bluxbh9CaQ0?t=10737)
.

ЗАМЫКАНИЕ ФУНКЦИИ
 
Когда из одной функции возвращаем другую функцию и дальше там происходит сохранение 
некоторого контекста.
(пример https://youtu.be/Bluxbh9CaQ0?t=10891)

-------------------------------------------------

МАССИВЫ (обозначаются квадратными скобками [])

const cars = ['Toyota', 'Mazda', 'Ford', 'BMW']  - массив, записанный в предпочтительном варианте. 

Добавление в массив новый элемент в конец - cars.push('Reno') - пуш это метод. 
Добавить в массив новый элемент в начало - cars.unshift('Porsche')
Удалить перовый элемент из массива - cars.shift()
Удалить последний элемент из массива - cars.pop()
Перевернуть весь массив - cars.reverse()
Найти элемент в массиве (возвращает индекс того элемента, который мы ищем) - cars.indexOf('BMW')
Узнать есть ли элемент в массиве - cars.includes('Mazda')

-- Методы более сложного порядка 
const upperCaseCars = cars.map(car => {         -метод мэп всегда возвращает новый массив. 
  return car.toUpperCase()


Пример задачи с переворачиванием строки, делением ее на массив ( https://youtu.be/Bluxbh9CaQ0?t=11839 )
-------------------------------------------------

ОБЪЕКТЫ

в объект группируем различный вид значений и создаем разные структуры:

const person = {                         передаем переменные, массивы, булеан значения, метод
  firstName: 'Yarik',                    любые ключи внутри объекта можно изменять, добавлять - person.hasWife = true
  lastName: 'Ivanov',
  year: 1964,
  languages: ['Ru', 'En', 'De'],
  hasWife: false,
  greet: function() {
    console.log('greet')   
  }
}

---------------------------------------------------

АСИНХРОННОСТЬ 
.
Event loop. 
.
setTimeout ( () => {                пример асинхронности.Функция принимает в себя два аргумента :
  console.log('After timeout')      1 - функция колбэк
}, 2500)                            2 - непосредственно сам таймаут (в милисекундах). 

setInterval ( () => {               пример асинхронности интервала.Функция принимает в себя два аргумента :
  console.log('After timeout')      1 - функция колбэк
}, 1500)                            2 - непосредственно сам таймаут (в милисекундах). Через какой промежуток времени...


-- Промисы 






